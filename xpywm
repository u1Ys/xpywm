#!/usr/bin/env python3
#
#       $Id: xpywm,v 1.16 2019/09/25 00:40:32 u1 Exp u1 $

import os
import re
import subprocess
import sys

from Xlib import X, display, XK
import Xlib

FRAME_WIDTH = 2
FRAME_COLOR = os.environ.get('THEME_COLOR', 'aquamarine1')
Y_OFFSET = 8
PNT_OFFSET = 16
DRAG_THRESH = 16
MIN_WIN_SIZE = 16
BOUNCE_RATIO = 1 / 8
MAX_VSCREEN = 3
TRANSSET_ALPHA = '.85'
PY_SENDSCREEN_W, PY_SENDSCREEN_H = 800, 600

EVENT_HANDLER = {
    X.KeyPress: 'handle_keypress',
    X.ButtonPress: 'handle_button_press',
    X.MotionNotify: 'handle_motion_notify',
    X.ButtonRelease: 'handle_button_release',
    X.MapRequest: 'handle_map_request',
    X.ConfigureRequest: 'handle_configure_request',
    X.UnmapNotify: 'handle_unmap_notify',
    X.EnterNotify: 'handle_enter_notify',
    X.LeaveNotify: 'handle_leave_notify',
    X.DestroyNotify: 'handle_destroy_notify',
    X.MapNotify: 'handle_map_notify',
}

KEYBOARD_HANDLER = {
    'i':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_method', 'args': ('focus_n_p_window', 1)},
    'o':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_method', 'args': ('focus_n_p_window', -1)},
    'p':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_method', 'args': ('focus_recent_window',)},
    'comma':
    {'modifier': X.Mod1Mask | X.ControlMask, 'method': 'layout_all_windows'},
    'period':
    {'modifier': X.Mod1Mask | X.ControlMask, 'method': 'tile_all_windows'},
    'apostrophe':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_maximize_window'},
    'semicolon':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_maximize_window', 'args': (False,)},
    'l':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_maximize_window_with_pysendscreen'},
    'k':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_transset'},
    'q':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_method', 'args': ('move_another_vscreen', 0)},
    'w':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_method', 'args': ('move_another_vscreen', 1)},
    'e':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_method', 'args': ('move_another_vscreen', 2)},
    'r':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_method', 'args': ('move_another_vscreen', 3)},
    'x':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_toogle_last_vscreen'},
    't':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_all_window_move_init_vscreen'},
    'z':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_destroy_window'},
    '1':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'method': 'cb_raise_emacs'},
    '2':
    {'modifier': X.Mod1Mask | X.ControlMask, 'callback': True,
     'command': '(unset STY; rxvt-unicode) &'
    },
    '3':
    {'modifier': X.Mod1Mask | X.ControlMask, 'method': 'raise_class_window', 'args': 'chromium'},
    '4':
    {'modifier': X.Mod1Mask | X.ControlMask, 'method': 'raise_class_window', 'args': 'firefox'},
    '0':
    {'modifier': X.Mod1Mask | X.ControlMask,
     'command': '{}/bin/init/recall-xutils &'.format(os.getenv('HOME', ''))},
    'F1': {'modifier': X.Mod1Mask, 'method': 'select_vscreen', 'args': 0},
    'F2': {'modifier': X.Mod1Mask, 'method': 'select_vscreen', 'args': 1},
    'F3': {'modifier': X.Mod1Mask, 'method': 'select_vscreen', 'args': 2},
    'F4': {'modifier': X.Mod1Mask, 'method': 'select_vscreen', 'args': 3},
    'F5': {'modifier': X.ShiftMask, 'function': 'screeshot'},
    'F6': {'modifier': X.ShiftMask, 'callback': True, 'method': 'cb_screenshot'},
    'F7': {'modifier': X.ShiftMask, 'command': 'xrandr-auto --mode 800x600'},
    'F8': {'modifier': X.ShiftMask, 'command': 'xrandr-auto --mode 1920x1080'},
    'F9':  {'modifier': X.ShiftMask, 'command': 'control-mplayer pause &'},
    'F10': {'modifier': X.ShiftMask, 'command': 'control-mplayer pt_step -1 &'},
    'F11': {'modifier': X.ShiftMask, 'command': 'control-mplayer pt_step  1 &'},
    'F12':
    {'modifier': X.ShiftMask,
     'command': 'pidof mplayer && control-mplayer quit || play-music -ar &'},
    'XF86WLAN':
    {'modifier': X.NONE, 'command': 'pidof wpa_supplicant && sudo wi_cli stop || sudo wi_cli start &'},
    'XF86Tools': {'modifier': X.NONE, 'command': 'sudo wi_cli reconf-ip &'},
    'XF86AudioRaiseVolume': {'modifier': X.NONE, 'function': 'audio_raise_volume'},
    'XF86AudioLowerVolume': {'modifier': X.NONE, 'function': 'audio_lower_volume'},
    'XF86AudioMute': {'modifier': X.NONE, 'function': 'audio_toggle_mute'},
    'XF86MonBrightnessUp': {'modifier': X.NONE, 'command': 'backlight -inc 10'},
    'XF86MonBrightnessDown': {'modifier': X.NONE, 'command': 'backlight -dec 10'},
    'a': {'modifier': X.Mod1Mask | X.ControlMask, 'function': 'backlight_toggle',
          'args': (40, 100)},
    's': {'modifier': X.Mod1Mask | X.ControlMask, 'function': 'backlight_toggle',
          'args': (1, 0)},
    'd': {'modifier': X.Mod1Mask | X.ControlMask, 'command': 'xcalib -i -alter'},
   'XF86AudioMicMute': {'modifier': X.NONE, 'command': 'xtrlock -b'},
   'XF86Display': {'modifier': X.NONE, 'command': 'xrandr-toggle'},
    # for debugging
    'Delete': {'modifier': X.Mod1Mask | X.ControlMask, 'function': 'restart'},
    'bracketright': {
        'modifier': X.Mod1Mask | X.ControlMask, 'function': 'trace'
    },
}

KEYSYM_TBL = {
    # https://cgit.freedesktop.org/xorg/proto/x11proto/tree/XF86keysym.h -u1 [2018/06/09]
    'XF86AudioRaiseVolume': 0x1008ff13, 'XF86AudioLowerVolume': 0x1008ff11,
    'XF86AudioMute': 0x1008ff12, 'XF86AudioMicMute': 0x1008ffb2,
    'XF86MonBrightnessUp': 0x1008ff02, 'XF86MonBrightnessDown': 0x1008ff03,
    'XF86WLAN': 0x1008ff95, 'XF86Tools': 0x1008ff81,
    'XF86Display': 0x1008ff59
}

LAYOUT_RULES = {
    r'xterm|rxvt': [.5, .3, 1 - .5, .7],
    r'emacs': [0, 0, .5, 1],
    r'firefox|iceweasel|chrom(e|ium)|midori':
    [.5, 0, .5, 1],
    r'(open|libre)office|acroread|xpdf|evince|mupdf|xdvi|tgif|xmathematical|gv':
    [.5, 0, .5, 1],
}

TILE_COUNTS = {
    0: [0, 0],
    1: [1, 1],
    2: [2, 1],
    3: [2, 2],
    4: [2, 2],
    5: [3, 2],
    6: [3, 2],
    7: [3, 3],
    8: [3, 3],
    9: [3, 3],
    10: [4, 3],
    11: [4, 3],
    12: [4, 3],
    13: [4, 4],
    14: [4, 4],
    15: [4, 4],
    16: [4, 4],
    17: [5, 4],
    18: [5, 4],
    19: [5, 4],
    20: [5, 4],
    21: [5, 5],
    22: [5, 5],
    23: [5, 5],
    24: [5, 5],
    25: [5, 5],
    26: [6, 5],
    27: [6, 5],
    28: [6, 5],
    29: [6, 5],
    30: [6, 5],
}

def debug(fmt, *args):
    if args:
        msg = '** debug: ' + fmt % args
    else:
        msg = '** debug: ' + fmt
    i = msg.find(' ->')
    if i >= 0:
        msg = msg[0:i] + (' ' * (50 - i)) + msg[i:]
    print(msg, file=sys.stderr)

def error(fmt, *args):
    if args:
        print('** error:', fmt % args, file=sys.stderr)
    else:
        print('** error:', fmt, file=sys.stderr)

def restart():
    debug('restarting %s...', sys.argv[0])
    os.execvp(sys.argv[0], [sys.argv[0]])

def exit():
    debug('terminating...')
    sys.exit()

def get_mixer_level():
    """Return the master playback volume of the default ALSA audio device.
    Volume ranges between 0 and 100."""
    output = subprocess.getoutput('amixer get Master')
    m = re.search(r'Playback.*\[(\d+)%\]', output)
    if m:
        level = int(m.group(1))
        debug('get_mixer_level -> %d', level)
        return level
    else:
        return None

def set_mixer_level(level):
    debug('set_mixer_level: %d', level)
    subprocess.getoutput('amixer set Master {}%'.format(level))

def audio_raise_volume(delta=5):
    debug('audio_raise_volume: %s', delta)
    level = get_mixer_level()
    if level is not None:
        level = max(0, min(level + delta, 100))
        set_mixer_level(level)

def audio_lower_volume(delta=5):
    debug('audio_lower_volume: %s', delta)
    audio_raise_volume(-delta)

def audio_toggle_mute():
    debug('audio_toggle_mute')
    output = subprocess.getoutput('amixer get Master')
    m = re.search(r'\[(\w+)\]', output)
    if m:
        toggle = m.group(1)
    else:
        return
    toggle = 'off' if toggle == 'on' \
             else 'on'
    os.system(f'amixer set Master {toggle}')

def backlight_toggle(brightness_a, brightness_b):
    try:
        brightness = int(subprocess.getoutput('backlight -get'))
    except:
        return
    brightness_new = brightness_b if brightness == brightness_a \
                     else brightness_a
    os.system(f'backlight -set {brightness_new}')

def _touchpad_set(enable):
    val = 0 if enable is True \
          else 1
    os.system(f'synclient TouchpadOff={val}')

def touchpad_set(cls):
    m = re.search(r'rxvt|emacs', cls.lower())
    _touchpad_set(bool(not(m)))

def screeshot(window='root'):
    os.system(f'import -window {window} /tmp/`date +%y%m%d-%H:%M:%S`.png')

class Geometry:
    def __init__(self, x=0, y=Y_OFFSET):
        self.x, self.y = x, y

class WindowManager():
    def __init__(self):
        # X server display & screen
        self.display = display.Display()
        self.screen = self.display.screen()
        self.colormap = self.screen.default_colormap

        self.key_handlers = {}
        self.focused_window = None
        self.managed_windows = []
        self.exposed_windows = []
        self.current_vscreen = 0
        self.window_vscreen = {}
        self.vscreen_pointer_geom = { _: Geometry()
                                      for _ in range(MAX_VSCREEN+1) }

        self.frame_windows = {}
        self.frame_gc = None

        self.geometries = {}
        self.last_focused_window = None
        self.last_raised_window = None
        self.last_vscreen = None

        self.drag_window = None
        self.drag_button = None
        self.drag_geometry = None
        self.drag_start_xy = None
        self.drag_last_xy = None

    def catch_events(self):
        """Configure the root window to receive all events needed for managing
        windows."""
        mask = (X.SubstructureRedirectMask | X.SubstructureNotifyMask
                | X.EnterWindowMask | X.LeaveWindowMask | X.FocusChangeMask)
        self.screen.root.change_attributes(event_mask=mask)

    def grab_keys(self):
        """Configure the root window to receive key inputs according to the
        key definitions `KEYBOARD_HANDLER'.  Also, the jump table is stored in
        `self.key_handlers'."""
        for string, entry in KEYBOARD_HANDLER.items():
            keysym = XK.string_to_keysym(string)
            # FIXME: use keysymdef/xf86.py
            if not keysym and string in KEYSYM_TBL:
                keysym = KEYSYM_TBL[string]
            keycode = self.display.keysym_to_keycode(keysym)
            if not keycode:
                continue

            modifier = entry.get('modifier', X.NONE)
            self.screen.root.grab_key(keycode, modifier, True, X.GrabModeAsync,
                                      X.GrabModeAsync)
            self.key_handlers[keycode] = entry
            debug('grab_key: %s, %s', string, entry)

    def grab_buttons(self):
        """Configure the root window to receive mouse button events."""
        for button in [1, 3]:
            self.screen.root.grab_button(button, X.Mod1Mask, True,
                                         X.ButtonPressMask, X.GrabModeAsync,
                                         X.GrabModeAsync, X.NONE, X.NONE)
            debug('grab_button: %d', button)

    # ---------------- X wrapper functions
    def is_alive_window(self, window):
        """Check if the window WINDOW do exist."""
        windows = self.screen.root.query_tree().children
        return window in windows

    def get_window_class(self, window):
        """Fetch the WM_CLASS window property of the window WINDOW and return
        the class part of the property.  Return empty string if class is not
        retrieved."""
        try:
            cmd, cls = window.get_wm_class()
        except:
            return ''
        if cls is not None:
            return cls
        else:
            return ''

    def window_shortname(self, window):
        return format('0x{:x} [{}]'.format(window.id,
                                           self.get_window_class(window)))

    def get_window_name(self, window):
        output = subprocess.getoutput('xwininfo -id 0x{:x}'.format(window.id))
        m = re.search(r'0x{:x} \"(.+)\"'.format(window.id), output)
        if not m:
            return ''
        name = m.group(1)
        return name

    def get_screen_size(self):
        width, height = self.screen.width_in_pixels, self.screen.height_in_pixels
        output = subprocess.getoutput('xrandr --current')
        m = re.search(r'[^e](DP-?\d|HDMI-?\d) connected (\d+)x(\d+)\+(\d+)\+(\d+)', output)
        if m and int(m.group(4)) == 0:
            width, height = int(m.group(2)), int(m.group(3))
        debug('get_screen_size -> w:%d h:%d', width, height)
        return width, height

    def get_usable_screen_size(self):
        width, height = self.get_screen_size()
        width -= FRAME_WIDTH * 2
        height -= FRAME_WIDTH * 2 + Y_OFFSET
        debug('get_usable_screen_size -> w:%d h:%d', width, height)
        return width, height

    def get_pointer_geometry(self):
        return Geometry(x=self.screen.root.query_pointer().root_x,
                        y=self.screen.root.query_pointer().root_y)

    # ---------------- window manager functions
    def is_managed_window(self, window):
        """Check if the window WINDOW is under the control of the window
        manager."""
        return window in self.managed_windows

    def is_exposed_window(self, window):
        return window in self.exposed_windows

    def is_frame_window(self, window):
        """Check if the window WINDOW is one of frame windows."""
        return window in self.frame_windows

    def convert_geomtry (self, x, y, width, height):
        screen_width, screen_height = self.get_usable_screen_size()
        px, py = 0, Y_OFFSET

        px += FRAME_WIDTH + int(screen_width * x)
        py += FRAME_WIDTH + int(screen_height * y)
        pwidth, pheight = int(screen_width * width), int(screen_height * height)

        debug('convert_geomtry: x=%s y=%s w=%s h=%s -> x:%s y:%s w:%s h:%s',
              x, y, width, height, px, py, pwidth, pheight)
        return {'x': px, 'y': py, 'width': pwidth, 'height': pheight}

    def create_frame_windows (self):
        """Create and map a window frame consisting of four windows."""
        debug('create_frame_windows')
        colormap = self.screen.default_colormap
        # create four frame windows
        pixel = colormap.alloc_named_color(FRAME_COLOR).pixel
        for side in ['frame_l', 'frame_r', 'frame_u', 'frame_d']:
            window = self.screen.root.create_window(
                0,
                0,
                16,
                16,
                0,
                self.screen.root_depth,
                X.InputOutput,
                background_pixel=pixel,
                override_redirect=1,
            )
            window.map()
            self.frame_windows[side] = window

    def draw_frame_windows(self, window):
        """Draw a frame window surrounding a windwow WINDOW."""
        debug('draw_frame_windows: %s', window)      

        if not self.is_alive_window(window):
            return
        try:
            geom = window.get_geometry()
        except Xlib.error.BadWindow or Xlib.error.BadDrawable:
            return

        self.focused_window = window

        for side in ['frame_l', 'frame_r', 'frame_u', 'frame_d']:
            x, y, width, height = 0, 0, 0, 0
            if side == 'frame_l':
                x = geom.x - FRAME_WIDTH
                y = geom.y
                width = FRAME_WIDTH
                height = geom.height
            elif side == 'frame_r':
                x = geom.x + geom.width
                y = geom.y
                width = FRAME_WIDTH
                height = geom.height
            elif side == 'frame_u':
                x = geom.x - FRAME_WIDTH
                y = geom.y - FRAME_WIDTH
                width = geom.width + 2 * FRAME_WIDTH
                height = FRAME_WIDTH
            elif side == 'frame_d':
                x = geom.x - FRAME_WIDTH
                y = geom.y + geom.height
                width = geom.width + 2 * FRAME_WIDTH
                height = FRAME_WIDTH

            win = self.frame_windows[side]
            win.configure(x=x, y=y, width=width, height=height)

            # NOTE: might be redundant
            win.map()
            win.raise_window()

    def clear_frame_window(self, window):
        if self.focused_window == window:
            debug('clear_frame_window')
            for side in ['frame_l', 'frame_r', 'frame_u', 'frame_d']:
                win = self.frame_windows[side]
                win.unmap()

    def warp_pointer(self, window):
        geom = window.get_geometry()
        window.warp_pointer(geom.width - PNT_OFFSET, PNT_OFFSET)

    def warp_pointer_abs(self, x, y):
        geom = self.get_pointer_geometry()
        self.display.warp_pointer(x - geom.x, y - geom.y)

    def manage_window(self, window):
        """The window WINDOW is put under the control of the window manager.
        The window is forced to be mapped on the current virtual screen.  The
        geometry of the window is unchnaged."""
        if not self.is_alive_window(window):
            return
        # skip if the window seems invalid
        try:
            attrs = window.get_attributes()
        except Xlib.error.BadWindow:
            return
        # skip if the window should not be intercepted by window manager
        if attrs.override_redirect:
            return
        # skip if the window is under our control
        if self.is_managed_window(window):
            return

        debug('manage_window: %s', self.window_shortname(window))
        self.managed_windows.append(window)
        self.exposed_windows.append(window)
        self.window_vscreen[window] = self.current_vscreen
        window.map()
        mask = X.EnterWindowMask | X.LeaveWindowMask
        window.change_attributes(event_mask=mask)
        if not self.is_browser_window(window):
            os.system('pidof xcompmgr && transset --id {} {}'.format(window.id, TRANSSET_ALPHA))

    def unmanage_window(self, window):
        """The window WINDOW leaves from the control of the window manager."""
        debug('unmanage_window')
        if self.is_managed_window(window):
            debug('unmanage_window: %s', self.window_shortname(window))
            if window in self.managed_windows:
                self.managed_windows.remove(window)
            if self.is_exposed_window(window):
                self.exposed_windows.remove(window)            
            del self.window_vscreen[window]

    def raise_window(self, window):
        """Make the window WINDOW above all other windows."""
        if not self.is_managed_window(window):
            return
        window.configure(stack_mode=X.Above)
        self.last_raised_window = window

    def lower_window(self, window):
        """Lower the window WINDOW among all other windows."""
        if not self.is_managed_window(window):
            return
        window.configure(stack_mode=X.Below)
        if self.last_raised_window == window:
            self.last_raised_window = None

    def raise_or_lower_window(self, window):
        """Raise or lower the window WINDOW.  Toggle the mode of operation at
        every invokation."""
        if self.last_raised_window == window:
            self.lower_window(window)
        else:
            self.raise_window(window)

    def focus_window(self, window):
        """Activate the input to the window WINDOW and the window frame is
        displayed."""
        if not self.is_managed_window(window) or not self.is_alive_window(window):
            return
        
        cls = self.get_window_class(window)
        touchpad_set(cls)

        # FIXME: called two times? might be redundant
        debug('focus_window: %s', self.window_shortname(window))
        
        window.set_input_focus(X.RevertToParent, 0)
        self.draw_frame_windows(window)

    def focus_n_p_window(self, window=None, next_previous=1):
        """Change the active window from the window WINDOW to the next one.
        The active window is raised and focused.  The pointer is moved to the
        north-west of the window."""
        debug('focus_n_p_window')

        def _sort_key(window):
            geom = window.get_geometry()
            return geom.x * 10000 + geom.y

        # sort active windows with their geometries
        windows = sorted(self.exposed_windows, key=_sort_key)

        # If no window alive, do nothing -u1 [2018/06/09]
        if not windows:
            return
        
        try:
            i = windows.index(window)
            next_window = windows[(i + next_previous) % len(windows)]
        except:
            next_window = windows[0]

        next_window.raise_window()
        self.warp_pointer(next_window)
        self.focus_window(next_window)

    def focus_recent_window(self, window):
        """Focus recently used window."""
        if not self.is_exposed_window(self.last_focused_window) or \
           window == self.last_focused_window:
            return       
        next_window = self.last_focused_window
        next_window.raise_window()
        self.warp_pointer(next_window)
        self.focus_window(next_window)

    def pull_class_window(self, cls):
        class_window = self.find_managed_class_window(cls)
        if not class_window:
            return False

        if self.window_vscreen[class_window] != self.current_vscreen:
            self.exposed_windows.append(class_window)
            self.window_vscreen[class_window] = self.current_vscreen
            class_window.map()
        self.focus_class_window(cls)

    def focus_class_window(self, cls):
        class_window = self.find_exposed_class_window(cls)
        if not class_window:
            return False

        self.raise_window(class_window)
        self.focus_window(class_window)
        self.warp_pointer(class_window)
        return True

    def raise_class_window(self, cmd):
        if not self.focus_class_window(cmd):
            os.system(f'{cmd} &')

    def move_another_vscreen(self, window, n):
        if not window:
            return

        try:
            vscreen_win = self.window_vscreen[window]
        except:
            return
        if vscreen_win != n:
            debug('move_another_vscreen: %s %s', self.window_shortname(window), n)
            self.window_vscreen[window] = n
            if window in self.exposed_windows:
                self.exposed_windows.remove(window)
                window.unmap()

    def is_maximized(self, window):
        """Check if the window WINDOW seems to have been maximized."""
        geom = window.get_geometry()
        width, height = self.get_usable_screen_size()
        if geom.x == 0 and geom.width == width:
            return True
        if geom.y == Y_OFFSET and geom.height == height:
            return True
        return False

    def save_window_geometry(self, window):
        """Save the current geometry of the window WINDOW."""
        geom = window.get_geometry()
        self.geometries[window] = {
            'x': geom.x, 'y': geom.y, 'width': geom.width, 'height':
            geom.height
        }

    def load_window_geometry(self, window):
        """Return the saved geometry of the window WINDOW.  If not saved yet,
        return None."""
        return self.geometries.get(window, None)

    def maximize_window(self, window, horizontally=True, vertically=True):
        """Resize the geometry of the window WINDOW to cover the screen
        horizontally and/or vertically."""
        if not self.is_exposed_window(window):
            return
        geom = window.get_geometry()
        x, y = geom.x, geom.y
        width, height = geom.width, geom.height

        screen_width, screen_height = self.get_screen_size()

        if horizontally:
            x, width = 0, screen_width
        if vertically:
            y, height = Y_OFFSET, screen_height - Y_OFFSET
        window.configure(x=x, y=y, width=width, height=height, stack_mode=X.Above)

        self.draw_frame_windows(window)
        self.warp_pointer(window)

    def find_exposed_class_window(self, cls):
        for window in self.exposed_windows:
            if cls in self.get_window_class(window).lower():
                return window
        return False

    def find_managed_class_window(self, cls):
        for window in self.managed_windows:
            if cls in self.get_window_class(window).lower():
                return window
        return False

    def is_terminal_window(self, window):
        """Check if the window WINDOW seems to be a terminal emulator."""
        cls = self.get_window_class(window)
        return 'xterm' in cls.lower()

    def is_movie_window(self, window):
        debug('is_movie_window: %s', self.window_shortname(window))
        cls = self.get_window_class(window)
        if 'mplayer' in cls.lower():
            return True
        name = self.get_window_name(window)
        return re.search(r'ニコニコ動画|ニコニコ生放送|youtube|twitch|abema|openrec|amazonprime|動画再生', \
                         name.lower())

    def is_browser_window(self, window):
        return re.search('chrom|firefox', self.get_window_class(window).lower())
               
    def layout_window(self, window, cls, half=None):
        debug('layout_window: %s q=%s', self.window_shortname(window), half)
        for regexp, geom in LAYOUT_RULES.items():
            geom = [ *geom ]
            if re.search(regexp, cls, flags=re.IGNORECASE):
                if half is not None:
                    # 0, 1, 2, 3 = x, y, w, h
                    geom[3] *= 1/2
                    geom[1] += geom[3] * (half%2)

                debug("  rule found -> '%s': %s", regexp, geom)
                window.configure(**self.convert_geomtry(*geom))

    def layout_all_windows(self, *args):
        # count the number of terminal windows
        debug('layout_all_windows')

        nmovie = sum( [1 for window in self.exposed_windows \
                       if self.is_movie_window(window)] )
        movie_i = 0

        for window in self.exposed_windows:
            cls = self.get_window_class(window).lower()        
            if self.is_movie_window(window) and nmovie >= 2:
                self.layout_window(window, cls, half=movie_i)
                movie_i += 1
            else:
                self.layout_window(window, cls)

    def tile_all_windows(self, *args):
        debug('tile_all_windows')
        def _sort_key(window):
            # force Emacs be the last in the window list
            if 'emacs' in self.get_window_class(window).lower():
                return 0x7fffffff
            elif self.is_movie_window(window):
                return 0x00000000
            else:
                return window.id

        windows = sorted(self.exposed_windows, key=_sort_key)
        nwindows = len(windows)
        ncols, nrows = TILE_COUNTS[nwindows]
        for col in reversed(range(ncols)):
            for row in reversed(range(nrows)):
                if not windows:
                    break

                window = windows.pop(0)
                x = 1 / ncols * col
                y = 1 / nrows * row
                width = 1 / ncols
                height = 1 / nrows

                if nwindows == 1:
                    self.maximize_window(window)
                    break
                elif not windows:
                    # the last window is stretched to fill the remaining area
                    rest_height = 1 / nrows * row
                    y -= rest_height
                    height += rest_height

                debug('  %s @ (%d, %d) -> x:%s y:%s w:%s h:%s',
                      self.window_shortname(window), col, row, x, y, width,
                      height)
                window.configure(**self.convert_geomtry(x, y, width, height))

    def switch_half_windows(self, window=None):
        if window is not None:
            is_right = window.get_geometry().x < self.screen.width_in_pixels // 2
        else:
            is_right = self.get_pointer_geometry.x
        windows = []
        for win in self.exposed_windows:
            print(win)
            if (is_right and win.get_geometry().x < self.screen.width_in_pixels // 2) \
               or (not is_right and win.get_geometry().x >= self.screen.width_in_pixels // 2):
                windows.append( win )

        if not windows: return

        def _sort_key(win):
            geom = win.get_geometry()
            return geom.x * 10000 + geom.y
        windows = sorted(windows, key=_sort_key)

        try:
            i = windows.index(window)
            next_window = windows[(i + 1)]
        except:
            next_window = windows[0]

        next_window.raise_window()
        self.warp_pointer(next_window)
        self.focus_window(next_window)

    def select_vscreen(self, n):
        """Change the virtual screen to N."""
        debug('select_vscreen: %d', n)
        self.vscreen_pointer_geom[self.current_vscreen] = self.get_pointer_geometry()
        if self.current_vscreen != n:
            self.last_vscreen = self.current_vscreen
        self.current_vscreen = n
        self.warp_pointer_abs(self.vscreen_pointer_geom[self.current_vscreen].x,
                              self.vscreen_pointer_geom[self.current_vscreen].y)
        self.exposed_windows.clear()
        for window in self.managed_windows:
            if self.window_vscreen[window] == n:
                window.map()
                self.exposed_windows.append(window)
            else:
                window.unmap()
        os.system(f'echo {n+1} > /tmp/wm/wm_vscreen_num')

    def destroy_window(self, window):
        """Kill the window WINDOW."""
        debug('destroy_window: %s', self.window_shortname(window))
        if self.is_managed_window(window):
            window.destroy()
            self.unmanage_window(window)

    # ---------------- callback functions
    def cb_method(self, event, method, *args):
        window = event.child
        method = getattr(self, method, None)
        if not method:
            error("unable to call '%s'", method)
        debug(f'cb_method {method} {args}')
        method(window, *args)

    def cb_maximize_window(self, event, horizontally=True):
        window = event.child
        if self.is_maximized(window) and self.load_window_geometry(window):
            window.configure(**self.load_window_geometry(window))
            self.draw_frame_windows(window)
            self.warp_pointer(window)
        else:
            self.save_window_geometry(window)
            self.maximize_window(window, horizontally=horizontally)

    def cb_destroy_window(self, event):
        window = event.child
        self.destroy_window(window)

    def cb_raise_emacs(self, event):
        if subprocess.getoutput('pidof emacs'):
            self.pull_class_window("emacs")
        else:
            os.system('emacs &')

    def cb_all_window_move_init_vscreen(self, event):
        for window in self.managed_windows:
            self.move_another_vscreen(window, 0)
        self.select_vscreen(0)
            
    def cb_maximize_window_with_pysendscreen(self, event):
        window = event.child
        if not self.is_exposed_window(window):
            return
        window.configure(x=0, y=Y_OFFSET, width=PY_SENDSCREEN_W, height=PY_SENDSCREEN_H-Y_OFFSET, \
                         stack_mode=X.Above)
        self.draw_frame_windows(window)
        self.warp_pointer(window)

    def cb_transset(self, event):
        window = event.child
        os.system(f'pidof xcompmgr && transset --toggle --id {window.id} {TRANSSET_ALPHA}')

    def cb_screenshot(self, event):
        window = event.child
        screeshot(window.id)

    def cb_toogle_last_vscreen(self, event):
        self.select_vscreen(self.last_vscreen)

    # ---------------- event handlers
    def handle_keypress(self, event):
        """Event handler for KeyPress events.  Callback functions for every
        key combination are defined in the variable `KEYBOARD_HANDLER', from
        which the jump table (dictionary mapping from a keycode to the
        corresponding action entry is composed and stored in
        `self.key_handlers'."""
        keycode = event.detail
        entry = self.key_handlers.get(keycode, None)
        if not entry:
            return

        debug('handle_keypress: %s -> %s', keycode, entry)
        args = entry.get('args', None)
        if 'method' in entry:
            method = getattr(self, entry['method'], None)
            if not method:
                error("unable to call '%s'", entry['method'])
            if 'callback' in entry:
                if args is not None:
                    method(event, *args)
                else:
                    method(event)
            else:
                method(args)
        elif 'function' in entry:
            function = globals().get(entry['function'], None)
            if function:
                if args is not None:
                    function(*args)
                else:
                    function()
            else:
                error("unable to call '%s'", entry['function'])
        elif 'command' in entry:
            os.system(entry['command'])

    def handle_button_press(self, event):
        """Initiate window repositioning with the button 1 or window resizing
        with the button 3.  All mouse pointer motion events are captured until
        the button is relased."""
        window = event.child
        if not self.is_managed_window(window):
            return

        self.screen.root.grab_pointer(
            True, X.PointerMotionMask | X.ButtonReleaseMask, X.GrabModeAsync,
            X.GrabModeAsync, X.NONE, X.NONE, 0)
        self.drag_window = window
        self.drag_button = event.detail
        self.drag_geometry = window.get_geometry()
        self.drag_start_xy = self.drag_last_xy = event.root_x, event.root_y

    def handle_button_release(self, event):
        """Terminate window repositioning/resizing."""
        self.display.ungrab_pointer(0)

    def handle_motion_notify(self, event):
        """Reposition or resize the current window according to the current
        pointer position.  The maximum rate of repositioning and resizeing is
        bounded by DRAG_MAX_FPS."""
        x, y = event.root_x, event.root_y
        # prevent to reposition window too frequently
        if abs(x - self.drag_last_xy[0]) + abs(
                y - self.drag_last_xy[1]) <= DRAG_THRESH:
            return
        self.drag_last_xy = x, y

        dx = x - self.drag_start_xy[0]
        dy = y - self.drag_start_xy[1]
        if self.drag_button == 1:
            # reposition
            self.drag_window.configure(x=self.drag_geometry.x + dx,
                                       y=self.drag_geometry.y + dy)
        else:
            # resize
            self.drag_window.configure(
                width=max(MIN_WIN_SIZE, self.drag_geometry.width + dx),
                height=max(MIN_WIN_SIZE, self.drag_geometry.height + dy))
        self.draw_frame_windows(self.drag_window)

    def handle_map_request(self, event):
        """Event handler for MapRequest events."""
        window = event.window
        self.manage_window(window)
        self.warp_pointer(window)
        self.focus_window(window)

    def handle_unmap_notify(self, event):
        """Event handler for UnmapNotify events."""
        window = event.window
        if window in self.exposed_windows:
            self.unmanage_window(window)
        self.clear_frame_window(window)

    def handle_map_notify(self, event):
        """Event handler for MapNotify events."""
        window = event.window
        if self.is_frame_window(window):
            return
        self.manage_window(window)

    def handle_enter_notify(self, event):
        """Event handler for EnterNotify events."""
        window = event.window
        if window in self.exposed_windows:
            self.focus_window(window)

    def handle_leave_notify(self, event):
        """Event handler for LeaveNotify events."""
        window = event.window
        self.last_focused_window = window

    def handle_destroy_notify(self, event):
        """Event handler for DestroyNotify events."""
        window = event.window
        self.unmanage_window(window)
        self.clear_frame_window(window)

    def handle_configure_request(self, event):
        """Event handler for ConfigureRequest events."""
        window = event.window
        x, y = event.x, event.y
        width, height = event.width, event.height
        mask = event.value_mask
        if mask == 0b1111:
            window.configure(x=x, y=y, width=width, height=height)
        elif mask == 0b1100:
            window.configure(width=width, height=height)
        elif mask == 0b0011:
            window.configure(x=x, y=y)
        elif mask == 0b01000000:
            window.configure(event.stack_mode)

    def event_loop(self):
        """The main event loop of the window manager.  Continuously receive an
        event from the X11 server, and dispatch an appropriate handler if
        possible."""
        while True:
            event = self.display.next_event()
            type = event.type
            if type in EVENT_HANDLER:
                handler = getattr(self, EVENT_HANDLER[type], None)
                if handler:
                    handler(event)

def main():
    wm = WindowManager()
    wm.catch_events()
    wm.grab_keys()
    wm.grab_buttons()

    for child in wm.screen.root.query_tree().children:
        # FIXME: should not skip unmapped windows?
        if child.get_attributes().map_state:
            wm.manage_window(child)

    wm.create_frame_windows()
    wm.select_vscreen(0)
    wm.event_loop()

if __name__ == "__main__":
    main()
